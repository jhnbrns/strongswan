/*
 * Copyright (c) 2019 Cisco and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

package kiknos.sswan;

/* Cryptographic algorithm for encryption */
enum CryptoAlg {
    NONE_CRYPTO = 0;
    AES_CBC_128 = 1;
    AES_CBC_192 = 2;
    AES_CBC_256 = 3;
    AES_CTR_128 = 4;
    AES_CTR_192 = 5;
    AES_CTR_256 = 6;
    AES_GCM_128 = 7;
    AES_GCM_192 = 8;
    AES_GCM_256 = 9;
    DES_CBC = 10;
    DES3_CBC = 11;
}

/* Cryptographic algorithm for authentication */
enum IntegAlg {
    NONE_INTEG = 0;
    MD5_96 = 1;
    SHA1_96 = 2;
    SHA_256_96 = 3;
    SHA_256_128 = 4;
    SHA_384_192 = 5;
    SHA_512_256 = 6;
}

// Return code in the responses
enum ReturnCode {
    OK = 0;
    FAIL = 1;
}

message Route {
    /* ip address + prefix in format <address>/<prefix> */
    string dst_network = 1;

    /* next hop address */
    string next_hop_addr = 2;

    /* outgoing interface name */
    string outgoing_interface = 3;

    /* The preference of the path. Lowest preference is preferred. */
    uint32 preference = 4;
}

/* IPSec tunnel-specific configuration */
message IPSecTunnel {
    string name = 1;

    /* Extended sequence number */
    bool esn = 2;

    /* Local IP address */
    string local_ip = 3;

    /* Remote IP address */
    string remote_ip = 4;

    /* Local security parameter index */
    uint32 local_spi = 5;

    /* Remote security parameter index */
    uint32 remote_spi = 6;

    /* Cryptographic algorithm for encryption */
    CryptoAlg crypto_alg = 7;
    string local_crypto_key = 8;
    string remote_crypto_key = 9;

    /* Cryptographic algorithm for authentication */
    IntegAlg integ_alg = 10;
    string local_integ_key = 11;
    string remote_integ_key = 12;


    /* Enable UDP encapsulation */
    bool enable_udp_encap = 13;

    /* unnumbered */
    string interface_with_ip = 14;
}


//  Allows otherwise dropped packet which destination IP address matching
//  some of the VPP interface IP addresses to be punted to the host.
//  L3 and L4 protocols can be used for filtering.
message SswanPuntSocket {
    // Destination port
    uint32 port = 1;

    // Unix domain socket to punt packets to the host.
    string socket_path = 2;
}

message SswanPuntSockets {
    // Per-punt-socket port and socket path configuration
    repeated SswanPuntSocket punt_sockets = 1;
}

message Response {
    ReturnCode rc = 1;
}

message IPAddress {
    // IPv4/IPv6 address
    string ip = 1;
}

message InterfaceName {
    // Interface name
    string name = 1;
}

message AgentPuntSktRqst {}

message AgentPuntSocket {
    string socket_path = 1;
}

message SSipSecStatsRqst {}

service SSipSec {
    // StrongSwan uses AddRoute to add a route for a tunnel
    rpc AddRoute (Route) returns (Response);

    // StrongSwan uses DelRoute to delete a route for a tunnel the tunnel
    rpc DelRoute (Route) returns (Response);

    // StrongSwan uses AddTunnel to add a tunnel
    rpc AddTunnel (IPSecTunnel) returns (Response);

    // StrongSwan uses DelTunnel to delete a tunnel
    rpc DelTunnel (IPSecTunnel) returns (Response);

    // Sets the paths for the punt sockets on which StrongSwan will expect
    // incoming IKE PDUs punted from VPP or the ESP node. One punt socket per
    // port (500 or 4500) is set.
    rpc SetSswanPuntSockets (SswanPuntSockets) returns (Response);

    // Gets the path for the punt socket to which StrongSwan will send the
    // outgoing IKE PDUs.
    rpc GetAgentPuntSocket (AgentPuntSktRqst) returns (AgentPuntSocket);

    // Get interface name based on IP address. Used by StrongSwan to
    // determine which IP addresses in its config file are local. An empty
    // string is returned for addresses not found, which is interpreted by
    // StrongSwan as the address being remote.
    rpc GetIfNameByIP (IPAddress) returns (InterfaceName);
}
